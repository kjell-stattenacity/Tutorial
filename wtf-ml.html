<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.376">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="author" content="Kjell Johnson &amp; Max Kuhn">
<title>What They forgot to Tell You about Machine Learning with an Application to Pharmaceutical Manufacturing</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>

<script src="wtf-ml_files/libs/clipboard/clipboard.min.js"></script>
<script src="wtf-ml_files/libs/quarto-html/quarto.js"></script>
<script src="wtf-ml_files/libs/quarto-html/popper.min.js"></script>
<script src="wtf-ml_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="wtf-ml_files/libs/quarto-html/anchor.min.js"></script>
<link href="wtf-ml_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="wtf-ml_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="wtf-ml_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="wtf-ml_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="wtf-ml_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
</head>
<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block default"><div class="quarto-title">
<h1 class="title">What They forgot to Tell You about Machine Learning with an Application to Pharmaceutical Manufacturing</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Kjell Johnson &amp; Max Kuhn </p>
          </div>
  </div>
    
  
    
  </div>
  


</header><section id="introduction" class="level2"><h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>It feels like machine learning is everywhere. Within data analysis circles, almost every discussion involves how artificial intelligence and machine learning can change our lives. ChatGPT has turned up the noise in the conversation, and many people believe it should be applied.</p>
<p>This tutorial discusses more realistic approaches to using machine learning in preclinical applications, specifically Chemistry, Manufacturing, and Control (CMC) applications. The structure takes a relatively ordinary experimental problem (predicting drug concentration using spectroscopy) to frame a discussion about what machine learning can and can’t do. The idea is that most machine learning tutorials are not holistic examinations of how it actually works. While describing our analysis, we will highlight “what they forgot to tell you” about these tools.</p>
<p>As an example, it might make sense to discuss what the term “machine learning” actually means and under what circumstances it is appropriate. Historically, it usually connotes a specific type of black-block model such as a neural network or support vector machine. This leads us to our our first <em>what they forgot</em> (WTF):</p>
<div class="wtf">
<p><strong>WTF #1</strong>: The idea of a “machine learning model” is more defined by the project’s goal than the type of model.</p>
</div>
<p>It is difficult to argue that ML models focus on making the most accurate prediction of a new sample based on historical data. From that point of view, it could be any sufficiently complex model that performs sufficiently well. For example, a linear regression could fit this definition by including appropriate interactions or nonlinear terms, such as spline basis expansions. However…</p>
<div class="wtf">
<p><strong>WTF #2</strong>: You probably don’t need a complex black-box machine learning model.</p>
</div>
<p>Why not? First, not all problems are purely prediction problems. Most black-box models used for ML, such as neural networks or tree ensembles, are excellent at prediction but poor at almost anything else. We have seen applications where simple two-factor experimental data were analyzed using the random forest ensemble method instead of a simple ANOVA model. When it comes to judging what predictors are important to one another, many machine learning models are not very applicable.</p>
<p>Another reason is the potential limitations of experimental data. Sometimes, there is not enough data to support fitting such a model. For example, if an unreplicated response surface design were available, training a model and characterizing its efficacy with so few data points would be difficult.</p>
<p>For some, there is a significant urge to fit complex ML models since they often are the best choice in completely different domains. These domains often have access to excessive amounts of non-tabular data. These are data structures that do not naturally fit into the traditional rectangular data format (e.g., spreadsheets or database tables). The most common examples are images, video, and text. Given a large amount of data and complex enough models, we have tools that recognize if a cat is in a picture or can ingest a prompt and appear to complete a task correctly, such as answering a question or writing code. These models are often complex deep-learning neural networks.</p>
<p>A disconnect occurs because most experimental data used in CMC applications are tabular (or can be made to be tabular).</p>
<div class="wtf">
<p><strong>WTF #3</strong>: Unless you are analyzing images, it is exceedingly unlikely that a deep-learning model is your best option.</p>
</div>
<p>There is considerable anecdotal evidence that highly complex neural networks may not perform well for reasonably sized tabular data sets. This is currently being examined more formally in the literature <span class="citation" data-cites="kadra2021regularization gorishniy2021revisiting Borisov2022 SHWARTZZIV202284">(<a href="#ref-kadra2021regularization" role="doc-biblioref">Kadra et al. 2021</a>; <a href="#ref-gorishniy2021revisiting" role="doc-biblioref">Gorishniy et al. 2021</a>; <a href="#ref-Borisov2022" role="doc-biblioref">Borisov et al. 2022</a>; <a href="#ref-SHWARTZZIV202284" role="doc-biblioref">Shwartz-Ziv and Armon 2022</a>)</span>. Experimental data in preclinical applications can often exhibit colinearity between predictors and data measured with error. For novel data sets, we often do not know which predictors have a relationship with the outcome, increasing the possibility that some irrelevant predictors will be used to fit the model. In general, neural networks do not thrive in these environments <span class="citation" data-cites="kuhn2013applied">(<a href="#ref-kuhn2013applied" role="doc-biblioref">Kuhn and Johnson 2013</a>)</span>.</p>
<p>Simply put, deep learning models can be effective in specific scenarios but are not appropriate in many other situations.</p>
<p>In this tutorial, we will discuss the process of constructing ML models for a specific data set. This process starts with understanding the available data’s predictors and response. After this initial understanding, we must then determine how to spend the data for the model-building process. Specifically, some data will need to be used to learn the generalizable characteristics that relate the predictors with the response (i.e., the training set). And other data will need to be used to assess how well the model predicts new data (i.e., the test set). After splitting the data, the predictors and/or the response may need to be preprocessed prior to modeling to enable better models to extract the predictive signal. After preprocessing, we can determine which types of predictive models to build. Each model has one or more parameters that determine how predictors are related to the response. In general, we do not know a priori which values of the tuning parameters are best. Therefore, we search a range of values to identify an optimal value. After identifying an optimal model, this model is then evaluated on the test data to determine if the model can be trusted to predict new, yet-to-be-seen samples reliably.</p>
<p>Let’s look a specific CMC application to further facilitate the discussion.</p>
</section><section id="experimental-setting" class="level2"><h2 class="anchored" data-anchor-id="experimental-setting">Experimental setting</h2>
<p>The manufacturing process of a biological drug is complex and requires careful monitoring to ensure that the cells are efficiently creating the drug product. This process can be very challenging to systematically control since the incubation process can take many days, and cells are complex biological entities that are affected by slight changes to environmental conditions. To ensure that the bioreactor conditions are conducive to the cells producing product, key attributes are measured by sampling the contents of the bioreactor daily. If attributes are not in an acceptable range, then steps must be taken to alter the conditions of the bioreactor. Generally, the sooner the conditions can be adjusted, the better the quantity and quality of the final drug product. Measuring the attributes takes time. Therefore, there is usually a lag between the attribute measurements and the corresponding adjustment. This lag can lead to less and lower-quality product.</p>
<p>Raman spectroscopy is a tool that can measure chemical characteristics (i.e., a chemical fingerprint) of samples in real-time <span class="citation" data-cites="jesus2020raman esmonde2022role silge2022trends">(<a href="#ref-jesus2020raman" role="doc-biblioref">Jesus, Löbenberg, and Bou-Chacra 2020</a>; <a href="#ref-esmonde2022role" role="doc-biblioref">Esmonde-White, Cuellar, and Lewis 2022</a>; <a href="#ref-silge2022trends" role="doc-biblioref">Silge et al. 2022</a>)</span>. Using the spectra in a predictive model of the characteristics of interest would enable real-time knowledge of and corresponding adjustments to the bioreactor, thus generating higher quality, larger volume drug product.</p>
<p>In the example outlined in this tutorial, several key input parameters were varied systematically across their operating ranges within each of the 60 small-scale bioreactors for producing a biological drug. Seven days after the start of the experiment, a sample was collected and analyzed by Raman spectroscopy. The concentration of the drug product in the sample was also measured. This analysis aims to understand how predictive Raman spectra can be of the drug product concentration. If there is a relationship, then the model could be used to signal if the bioreactor was insufficiently producing a product and prompting remedial steps to increase production.</p>
</section><section id="sec-understanding-the-data" class="level1"><h1>Understanding the Data</h1>
<p>The first step in any modeling process is to understand the available data.</p>
<div class="wtf">
<p><strong>WTF #4</strong>: the only way to be comfortable with your data is to never look at them.</p>
</div>
<p>In this application, there is one sample from each of 60 bioreactors. Raman spectroscopy has been applied to each sample, and the drug product concentration has been measured. <a href="#fig-raman-spectra" class="quarto-xref">Figure&nbsp;1</a> displays the original Raman spectra. From this figure, we can see that there is an initial downward trend towards the middle of the wavenumbers, then an upward trend towards the higher wavenumbers. The intensities are not randomly scattered. Instead, there is a relationship across wavenumbers with intensity. This relationship indicates that wavenumber intensities are correlated with each other. In fact, the correlation between the majority of adjacent wavenumbers is greater than 0.99.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div id="fig-raman-spectra" class="quarto-figure quarto-figure-center anchored" data-fig-align="center" width="80%">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-raman-spectra-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="wtf-ml_files/figure-html/fig-raman-spectra-1.png" class="img-fluid quarto-figure-center figure-img" style="width:80.0%">
</div>
<figcaption class="figure quarto-float-caption quarto-float-fig" id="fig-raman-spectra-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Raman spectra profiles for each of the 60 samples.
</figcaption></figure>
</div>
</div>
</div>
<p>To illustrate this more clearly, let’s examine the relationship among wavenumber measurements for the first sample. For the first sample, the first 3000 lags are created. To create a lag, the data is shifted by a specified number of rows to create a new variable. For example, to create the first lag, the wavenumber measurements are shifted over by one wavenumber. To create the second lag, the measurements are shifed by two wavenumberes, and so on. <a href="#fig-lagged-spectra" class="quarto-xref">Figure&nbsp;2</a> illustrates the correlation between each subquent lag for the first 1000 lags. Clearly, close wavenumbers have high correlation, whereas far wavenumbers have low correlation. As we will see, understanding this characteristic will turn out to be very important when making decisions about how to pre-process the data prior to modeling and which models to train.</p>
<div class="cell" data-layout-align="center" data-hash="_cache/fig-lagged-spectra_00e3a3db12e5b8e5aa88a0dda3e42453">
<div class="cell-output-display">
<div id="fig-lagged-spectra" class="quarto-figure quarto-figure-center anchored" data-fig-align="center" width="80%">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-lagged-spectra-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="wtf-ml_files/figure-html/fig-lagged-spectra-1.png" class="img-fluid quarto-figure-center figure-img" style="width:80.0%">
</div>
<figcaption class="figure quarto-float-caption quarto-float-fig" id="fig-lagged-spectra-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: The correlation between the original intensities and lagged intensities for the first sample. As wavenumbers depart, the correlation of the intensities decreases.
</figcaption></figure>
</div>
</div>
</div>
<p>In addition to understanding the predictors, we should also understand characteristics of the response. Examining the response distribution can help determine if a transformation may be necessary or if there are samples that are unusual with respect to the majority of the data. <a href="#fig-concentration" class="quarto-xref">Figure&nbsp;3</a> presents the histogram drug product concentration across the samples. For this data, the distribution is approximately symmetric and has a range of 85 to 115. Based on this figure, a transformation does not appear to be necessary, and there are no samples that are unusual.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div id="fig-concentration" class="quarto-figure quarto-figure-center anchored" data-fig-align="center" width="80%">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-concentration-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="wtf-ml_files/figure-html/fig-concentration-1.png" class="img-fluid quarto-figure-center figure-img" style="width:80.0%">
</div>
<figcaption class="figure quarto-float-caption quarto-float-fig" id="fig-concentration-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: The distribution of drug product concentration across samples.
</figcaption></figure>
</div>
</div>
</div>
<section id="data-spending" class="level2"><h2 class="anchored" data-anchor-id="data-spending">Data Spending</h2>
<p>The primary objective of predictive modeling is to use the existing data to develop a model that predicts new samples as accurately as possible. To achieve this objective, a process must be implemented that avoids overfitting to the existing data <span class="citation" data-cites="kuhn2013applied Hawkins2004p1">(<a href="#ref-kuhn2013applied" role="doc-biblioref">Kuhn and Johnson 2013</a>; <a href="#ref-Hawkins2004p1" role="doc-biblioref">Hawkins 2004</a>)</span>. An overfit model is one that accurately predicts the response for the data on which the model was trained but does not accurately predict new data. To avoid overfitting, we must construct a model-building process that mimics the prediction process for new samples. One way to do this would be to split the data into training and test sets. A model could be constructed with the training set, then predictive performance could be evaluated with the test set.</p>
<div class="wtf">
<p><strong>WTF #5</strong>: Always have an independent data set that can contradict what you think you may know.</p>
</div>
<p>However, most predictive models must be constructed using a variety of tuning parameter values. The test set would then need to be evaluated multiple times to assess predictive performance. When the test set is evaluated multiple times, we are essentially finding a model that fits the test set. This process leads to overfitting, and the model performance cannot be trusted to evaluate the predictive performance on new samples accurately. Therefore, a single training/test split will not be adequate for building predictive models. Moreover, it is important to understand that the test set should only be used once to evaluate the final selected models.</p>
<p>Instead of a single training/test split, we need a process that can be used to evaluate many tuning parameter values for each of many different models. <a href="#fig-resampling" class="quarto-xref">Figure&nbsp;4</a> illustrates a two-layered process that incorporates the use of resampling. The first layer splits the entire data set into a training and test set. In general, anywhere between 50% to 80% of the data is randomly selected for the training data, while the remaining data is placed in the test set. A random split may be adequate. However, we may desire that the training set and testing split data have similar characteristics. For example, it may be advantageous for the training and test sets to have a similar distribution of the response. If the response distribution is skewed, then it would be important that the training and test sets reflect the entirety of the distribution. Likewise, if there are characteristics or covariates in the data that should be proportionally represented, then the data should be split into the training and testing set using a stratified random approach.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div id="fig-resampling" class="quarto-figure quarto-figure-center anchored" data-fig-align="center" width="80%">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-resampling-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="premade/resampling.svg" class="img-fluid quarto-figure-center figure-img" style="width:80.0%">
</div>
<figcaption class="figure quarto-float-caption quarto-float-fig" id="fig-resampling-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Illustration of a general data usage scheme that incorporates resampling.
</figcaption></figure>
</div>
</div>
</div>
<p>The training data is split using resampling in the second layer of <a href="#fig-resampling" class="quarto-xref">Figure&nbsp;4</a>. Cross-validation could be used in this layer, where the data is split into <span class="math inline">\(V\)</span> folds. For example, if 10-fold cross-validation were used in this layer, then the training data would be partitioned into 10 folds. The analysis set for the first resample would contain 9 folds of the data, while the assessment set would contain 1 fold of the data. A model would be constructed using the 9 folds and would evaluated using the hold-out fold. To create the analysis set for the second resample, a different combination of 9-folds would be used to construct the model. The model would then be evaluated on the fold that was not used in the modeling. For illustration, <a href="#fig-three-fold" class="quarto-xref">Figure&nbsp;5</a> provides an illustration of 3-fold cross-validation (although <span class="math inline">\(V = 10\)</span> is a much better choice).</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div id="fig-three-fold" class="quarto-figure quarto-figure-center anchored" data-fig-align="center" width="60%">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-three-fold-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="premade/three-CV.svg" class="img-fluid quarto-figure-center figure-img" style="width:60.0%">
</div>
<figcaption class="figure quarto-float-caption quarto-float-fig" id="fig-three-fold-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: A diagram of how 3-fold cross-validation can be used with 30 data points.
</figcaption></figure>
</div>
</div>
</div>
<p>For the example presented here, a stratified random approach will be used to split the data into a training (75%) and a test (25%) set. The distribution of the response will be used as the stratification variable such that an equal proportion of samples will be randomly selected within each quartile of the distribution. When training models, we will compare the performance of 10-fold cross-validation as well as repeated 10-fold cross-validation.</p>
</section><section id="pre-processing" class="level2"><h2 class="anchored" data-anchor-id="pre-processing">Pre-processing</h2>
<p>The predictors and response, in their original form, are usually not in the best form for enabling models to find an optimal predictive relationship. The original data may contain highly correlated predictors, predictors that lack information, missing values, multi-category predictors, or highly skewed predictors. Some models, such as those based on recursive partitioning algorithms, can handle most of these challenging characteristics. However, many models either cannot be built, or the predictive performance will be detrimentally impacted when one or more of these characteristics are present. As a simple example, consider a predictor that has three categories: Low, Mid, and High. The information, in this form, cannot be ingested by most models. Instead, the information needs to be converted into either an ordinal-scaled predictor or two binary variables. Missing data also wreaks havoc on predictive models because the models require non-missing information. Therefore, appropriate pre-processing steps must be taken before the model training.</p>
<div class="wtf">
<p><strong>WTF #6</strong>: The stereotypical concept of a model is confined to the supervised operation of estimating model parameters (e.g., slope and intercepts in linear regression).</p>
<p>However, it includes any serious data analysis steps before or after the stereotypical model fit. This can include steps such as PCA feature extraction, imputation, post hoc calibration, etc.</p>
</div>
<div class="wtf">
<p><strong>WTF #7</strong>: The operations that you apply to the predictors before the model are at least as important as which stereotypical model you use. <em>Feature engineering</em> is the process of representing the predictor data in a way that makes the model have to work the least to be effective.</p>
</div>

</section></section><div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Borisov2022" class="csl-entry" role="listitem">
Borisov, Vadim, Tobias Leemann, Kathrin Sessler, Johannes Haug, Martin Pawelczyk, and Gjergji Kasneci. 2022. <span>“Deep Neural Networks and Tabular Data: A Survey.”</span> <em><span>IEEE</span> Transactions on Neural Networks and Learning Systems</em>, 1–21.
</div>
<div id="ref-esmonde2022role" class="csl-entry" role="listitem">
Esmonde-White, Karen A, Maryann Cuellar, and Ian R Lewis. 2022. <span>“The Role of Raman Spectroscopy in Biopharmaceuticals from Development to Manufacturing.”</span> <em>Analytical and Bioanalytical Chemistry</em>, 1–23.
</div>
<div id="ref-gorishniy2021revisiting" class="csl-entry" role="listitem">
Gorishniy, Yury, Ivan Rubachev, Valentin Khrulkov, and Artem Babenko. 2021. <span>“Revisiting Deep Learning Models for Tabular Data.”</span> <em>Advances in Neural Information Processing Systems</em> 34: 18932–43.
</div>
<div id="ref-Hawkins2004p1" class="csl-entry" role="listitem">
Hawkins, D. 2004. <span>“The Problem of Overfitting.”</span> <em>Journal of Chemical Information and Computer Sciences</em> 44 (1): 1–12.
</div>
<div id="ref-jesus2020raman" class="csl-entry" role="listitem">
Jesus, José Izo Santana da Silva de, Raimar Löbenberg, and Nadia Araci Bou-Chacra. 2020. <span>“Raman Spectroscopy for Quantitative Analysis in the Pharmaceutical Industry.”</span> <em>Journal of Pharmacy and Pharmaceutical Sciences</em> 23 (1): 24–46.
</div>
<div id="ref-kadra2021regularization" class="csl-entry" role="listitem">
Kadra, Arlind, Marius Lindauer, Frank Hutter, and Josif Grabocka. 2021. <span>“Regularization Is All You Need: Simple Neural Nets Can Excel on Tabular Data.”</span> <em>arXiv</em> 536.
</div>
<div id="ref-kuhn2013applied" class="csl-entry" role="listitem">
Kuhn, Max, and Kjell Johnson. 2013. <em>Applied Predictive Modeling</em>. Springer.
</div>
<div id="ref-SHWARTZZIV202284" class="csl-entry" role="listitem">
Shwartz-Ziv, Ravid, and Amitai Armon. 2022. <span>“Tabular Data: Deep Learning Is Not All You Need.”</span> <em>Information Fusion</em> 81: 84–90.
</div>
<div id="ref-silge2022trends" class="csl-entry" role="listitem">
Silge, A, Karina Weber, D Cialla-May, L Müller-Bötticher, D Fischer, and J Popp. 2022. <span>“Trends in Pharmaceutical Analysis and Quality Control by Modern Raman Spectroscopic Techniques.”</span> <em>TrAC Trends in Analytical Chemistry</em> 153: 116623.
</div>
</div></section></div></main><!-- /main column --><script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        for (let i = 0; i < 2; i++) {
          container.appendChild(note.children[i].cloneNode(true));
        }
        return container.innerHTML
      } else {
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        console.log("RESIZE");
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>